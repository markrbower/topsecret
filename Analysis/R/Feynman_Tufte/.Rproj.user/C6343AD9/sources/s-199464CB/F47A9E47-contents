findAllPeaksThenIdentifySignalsAndAddToGraph <- function( parameters, state, filteredData, correlationWindow ) {
  library(signal)
  library(igraph)
  library(iterators)
  library(itertools)
  
  source('~/Dropbox/Documents/Concepts/2019_11_19_NetworkParameterOutlier/Analysis/NPO/R/isLocalPeak_IIS.R')
  source('~/Dropbox/Documents/Concepts/2019_11_19_NetworkParameterOutlier/Analysis/NPO/R/findLocalPeak_IIS.R')
  source('~/Dropbox/Documents/Concepts/2019_11_19_NetworkParameterOutlier/Analysis/NPO/R/uUTC_from_samp.R')
  source('~/Dropbox/Documents/Concepts/2019_11_19_NetworkParameterOutlier/Analysis/NPO/R/IDv.R')
  source('~/Dropbox/Documents/Concepts/2019_11_19_NetworkParameterOutlier/Analysis/NPO/R/notInGraph.R')
  source('~/Dropbox/Documents/Concepts/2019_11_19_NetworkParameterOutlier/Analysis/NPO/R/anEvent.R')
  source('~/Dropbox/Documents/Concepts/2019_11_19_NetworkParameterOutlier/Analysis/NPO/R/graphInsertBuffer.R')
  source('~/Dropbox/Documents/Concepts/2019_11_19_NetworkParameterOutlier/Analysis/NPO/R/databaseInsertBuffer.R')
  
  options(stringsAsFactors = FALSE);
  
  dib <- state$dib
  gib <- state$gib

  if ( state$parametersNotSet == 1 ) {
    state$parametersNotSet = 0
    cc_th <- 0.8
    ed_th <- 1.5
  } else {
    cc_th <- state$cc_threshold
    ed_th <- state$ed_threshold
  }  
  
  blackout <- parameters$blackout
  
  skipSize <- 1
  
  # Establish widths
  # IIS
  #width <- 20 # Only used for setting "mask" below
  #mask <- seq(from=-width,to=width,by=1)
  # AP
  mask <- parameters$waveform_mask
  
  # Set sovereign_width
  secondsPerSample <- 1E6 / parameters$samplingFrequency
  sovereign_width <- round( blackout / secondsPerSample )
  
  filt_data_detect <- filteredData$filt_data_detect
  filt_data_keep <- filteredData$filt_data_keep
  s0 <- filteredData$s0
  t0 <- filteredData$t0
  dt <- filteredData$dt
  info <- filteredData$info

  # Find candidate peaks
  dw = diff(filt_data_detect);
  sdw = sign(dw);
  dsdw = diff(sdw);
  C = which( dsdw>0 | dsdw<0 ) + 1;
  N = length(C);
  
  bad = which( C < (abs(min(mask))+1) | C > ((length(filt_data_detect)-max(mask))-1) );
  if ( length(bad) > 0 ) {
    C <- C[-bad];
  }

  # Find peaks
#  print( paste0( "3.2 ", attr( grph, 'masterID' ) ) )
#  print( paste0( "Checking ", length(C), " peaks." ) )
  if ( length(C) > 0 ) {
    candidateIdx <- which( sapply( C, function(x) isLocalPeak_IIS(filt_data_detect, x, sovereign_width) ) )
    localPeaks <- C[candidateIdx]
    peakIdxCnt <- 0
    prev_c_ <- -999
    iterC <- ihasNext( iter( localPeaks ) )
    # print( "Starting the loop" )
    while( hasNext( iterC ) ) {
      c_ <- nextElem(iterC)
  #    if ( isLocalPeak_IIS(filt_data_detect, c_, sovereign_width) ) {
        # print( "Peak" )
        localPeak <- findLocalPeak_IIS( filt_data_detect, c_, sovereign_width )
        if ( localPeak>=(sovereign_width-4) & localPeak<=(sovereign_width+4) ) { # IIS
          # Shift to the actual peak
          c_ <- c_ + localPeak - sovereign_width - 1
          if ( c_ != prev_c_ ) {
            prev_c_ <- c_
            mask_idx <- c_ + mask
            if ( min(mask_idx)>0 & max(mask_idx)<=length(filt_data_keep) ) {
            tryCatch({
              peakIdxCnt = peakIdxCnt + 1;
              wvfrm = filt_data_keep[c_+mask];
              bad <- which( is.na( wvfrm ) )
              # Add to graph
              utc = uUTC_from_samp( (c_*skipSize)+s0, info$ToC, info$header); # re-instate downsampling factor
              utc = round( utc );
  #            print( gib$max_graph_time() - utc )
              if ( utc > gib$max_graph_time() ) {
                event_ <- anEvent( utc, wvfrm )
                gib$insert( event_ )
                gib$update( utc, state, dib )
              }
            },error=function(e) {
              print(e)
            })
          }
          } # previous c_ differs from current c_
        } # found the local peak
  #    } # is a local peak
    }
  } # next candidate
  
  state$dib <- dib
  state$gib <- gib
  
  return( state )
}
